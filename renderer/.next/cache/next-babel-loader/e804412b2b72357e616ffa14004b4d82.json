{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useQuery } from \"react-query\";\nimport axios from \"axios\";\nimport { ResponsiveContainer, LineChart, CartesianGrid, XAxis, YAxis, Tooltip, Legend, Line } from \"recharts\";\nimport { colors } from \"../constants\";\n\nconst fetchTimeSeriesData = async (type, statement, start, end, breakdown, resolution) => {\n  const res = await axios.get(`${process.env.NEXT_PUBLIC_API_URL}/graph/TimeSeries?${type === \"date\" && end !== \"\" ? `start=${start}&end=${end}` : `statement=${statement}`}&breakdown=${breakdown}&resolution=${resolution}`); // re-structure data\n\n  let arr = [];\n  res.data.series.map(series => series.dataPoints.map(point => {\n    const label = series.label;\n    const timestamp = new Date(point.time).getTime();\n\n    if (arr.some(obj => obj.timestamp === timestamp)) {\n      arr = arr.map(obj => obj.timestamp === timestamp ? _objectSpread(_objectSpread({}, obj), {}, {\n        [label]: point.value\n      }) : obj);\n    } else {\n      arr.push({\n        time: point.time,\n        timestamp: new Date(point.time).getTime(),\n        [label]: point.value\n      });\n    }\n  })); // sort data by timestamp in ascending order\n\n  const sorted = arr.sort((a, b) => a.timestamp - b.timestamp);\n  const labels = res.data.series.map(series => series.label);\n  return {\n    sorted,\n    labels\n  };\n};\n\nconst TimeSeriesLineGraph = ({\n  query,\n  size\n}) => {\n  const {\n    type,\n    statement,\n    start,\n    end,\n    breakdown,\n    resolution\n  } = query;\n  const {\n    data,\n    error,\n    isLoading\n  } = useQuery([type, statement, start, end, breakdown, resolution], fetchTimeSeriesData);\n  if (isLoading) return \"Loading...\";\n  if (error) return \"An error has occurred: \" + error.message;\n  return !isLoading && __jsx(ResponsiveContainer, {\n    width: size === \"small\" ? 700 : \"100%\",\n    height: size === \"small\" ? 300 : \"100%\"\n  }, __jsx(LineChart, {\n    data: data.sorted,\n    margin: {\n      top: 5,\n      right: 30,\n      left: 20,\n      bottom: 5\n    }\n  }, __jsx(CartesianGrid, {\n    strokeDasharray: \"3 3\"\n  }), __jsx(XAxis, {\n    dataKey: \"time\"\n  }), __jsx(YAxis, null), __jsx(Tooltip, null), __jsx(Legend, null), data.labels.map((label, index) => __jsx(Line, {\n    key: index,\n    connectNulls: true,\n    type: \"monotone\",\n    dataKey: label,\n    name: label,\n    stroke: colors[index % colors.length]\n  }))));\n};\n\nexport default TimeSeriesLineGraph;","map":null,"metadata":{},"sourceType":"module"}