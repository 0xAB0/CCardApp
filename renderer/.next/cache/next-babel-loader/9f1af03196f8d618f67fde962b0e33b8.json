{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useState, useEffect } from \"react\";\nimport { useRouter } from \"next/router\";\nimport axios from \"axios\";\nimport { makeStyles } from \"@material-ui/core/styles\";\nimport Typography from \"@material-ui/core/Typography\";\nimport Container from \"@material-ui/core/Container\";\nimport Paper from \"@material-ui/core/Paper\";\nimport TableContainer from \"@material-ui/core/TableContainer\";\nimport Table from \"@material-ui/core/Table\";\nimport TableHead from \"@material-ui/core/TableHead\";\nimport TableRow from \"@material-ui/core/TableRow\";\nimport TableCell from \"@material-ui/core/TableCell\";\nimport TableBody from \"@material-ui/core/TableBody\";\nimport Box from \"@material-ui/core/Box\";\nimport Button from \"@material-ui/core/Button\";\nimport TextField from \"@material-ui/core/TextField\";\nimport Autocomplete, { createFilterOptions } from \"@material-ui/lab/Autocomplete\";\nconst filter = createFilterOptions();\nconst useStyles = makeStyles(theme => ({\n  root: {\n    marginTop: theme.spacing(1)\n  },\n  box: {\n    margin: theme.spacing(3, 1)\n  }\n}));\nexport default function Import() {\n  const router = useRouter();\n  const classes = useStyles();\n  const {\n    0: rows,\n    1: setRows\n  } = useState([]);\n  const {\n    0: categoryList,\n    1: setCategoryList\n  } = useState([]);\n\n  const handleCategoryChange = async (event, newValue, rowId) => {\n    if (newValue) {\n      setRows(rows.map(item => item.rowId === rowId ? _objectSpread(_objectSpread({}, item), {}, {\n        category: newValue\n      }) : item));\n      await axios.put(`${process.env.NEXT_PUBLIC_API_URL}/import/${router.query.id}/${rowId}/category`, newValue, {\n        headers: {\n          \"Content-Type\": \"text/plain\"\n        }\n      });\n    }\n  };\n\n  const handleCommit = async () => {\n    const res = await axios.put(`${process.env.NEXT_PUBLIC_API_URL}/import/${router.query.id}/commit`);\n\n    if (res.data.status === \"ok\") {\n      const query = {\n        type: \"statement\",\n        statement: router.query.name\n      };\n      router.push({\n        pathname: \"/xray\",\n        query\n      });\n    }\n  };\n\n  useEffect(() => {\n    const fetchData = async id => {\n      const res = await axios.get(`${process.env.NEXT_PUBLIC_API_URL}/import/${id}/data`);\n      setRows(res.data.rows);\n    };\n\n    fetchData(router.query.id);\n  }, [router.query]);\n  useEffect(() => {\n    const fetchCategoryList = async () => {\n      const res = await axios.get(`${process.env.NEXT_PUBLIC_API_URL}/category/list`);\n      setCategoryList(res.data);\n    };\n\n    fetchCategoryList();\n  }, []);\n  return __jsx(Container, {\n    className: classes.root\n  }, __jsx(Typography, {\n    variant: \"h4\",\n    gutterBottom: true\n  }, \"Import\"), __jsx(TableContainer, {\n    component: Paper\n  }, __jsx(Table, null, __jsx(TableHead, null, __jsx(TableRow, null, __jsx(TableCell, null, \"Date\"), __jsx(TableCell, null, \"Description\"), __jsx(TableCell, null, \"Amount\"), __jsx(TableCell, null, \"Category\"))), __jsx(TableBody, null, rows.map(row => __jsx(TableRow, {\n    key: row.rowId\n  }, __jsx(TableCell, {\n    component: \"th\",\n    scope: \"row\"\n  }, row.date), __jsx(TableCell, null, row.description), __jsx(TableCell, null, row.amount), __jsx(TableCell, null, __jsx(Autocomplete, {\n    value: row.category,\n    onChange: (event, newValue) => {\n      handleCategoryChange(event, newValue, row.rowId);\n    },\n    filterOptions: (options, params) => {\n      const filtered = filter(options, params); // Suggest the creation of a new value\n\n      if (params.inputValue !== \"\") {\n        filtered.push(params.inputValue);\n      }\n\n      return filtered;\n    },\n    selectOnFocus: true,\n    clearOnBlur: true,\n    handleHomeEndKeys: true,\n    options: categoryList,\n    getOptionLabel: option => {\n      // Value selected with enter, right from the input\n      if (typeof option === \"string\") {\n        return option;\n      } // Add \"xxx\" option created dynamically\n\n\n      if (option.inputValue) {\n        return option.inputValue;\n      } // Regular option\n\n\n      return option.title;\n    },\n    size: \"small\",\n    freeSolo: true,\n    renderInput: params => __jsx(TextField, params)\n  }))))))), __jsx(Box, {\n    textAlign: \"right\",\n    className: classes.box\n  }, __jsx(Button, {\n    variant: \"contained\",\n    color: \"primary\",\n    onClick: handleCommit\n  }, \"Commit\")));\n}","map":null,"metadata":{},"sourceType":"module"}