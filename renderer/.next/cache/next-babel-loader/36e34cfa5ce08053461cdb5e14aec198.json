{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport React from \"react\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useQuery } from \"react-query\";\nimport axios from \"axios\";\nimport { ResponsiveContainer, LineChart, CartesianGrid, XAxis, YAxis, Tooltip, Legend, Line } from \"recharts\";\nimport { colors } from \"../constants\";\n\nvar fetchTimeSeriesData = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, statement, start, end, breakdown, resolution) {\n    var res, arr, sorted, labels;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return axios.get(\"\".concat(process.env.NEXT_PUBLIC_API_URL, \"/graph/TimeSeries?\").concat(type === \"date\" && end !== \"\" ? \"start=\".concat(start, \"&end=\").concat(end) : \"statement=\".concat(statement), \"&breakdown=\").concat(breakdown, \"&resolution=\").concat(resolution));\n\n          case 2:\n            res = _context.sent;\n            // re-structure data\n            arr = [];\n            res.data.series.map(function (series) {\n              return series.dataPoints.map(function (point) {\n                var label = series.label;\n                var timestamp = new Date(point.time).getTime();\n\n                if (arr.some(function (obj) {\n                  return obj.timestamp === timestamp;\n                })) {\n                  arr = arr.map(function (obj) {\n                    return obj.timestamp === timestamp ? _objectSpread(_objectSpread({}, obj), {}, _defineProperty({}, label, point.value)) : obj;\n                  });\n                } else {\n                  arr.push(_defineProperty({\n                    time: point.time,\n                    timestamp: new Date(point.time).getTime()\n                  }, label, point.value));\n                }\n              });\n            }); // sort data by timestamp in ascending order\n\n            sorted = arr.sort(function (a, b) {\n              return a.timestamp - b.timestamp;\n            });\n            labels = res.data.series.map(function (series) {\n              return series.label;\n            });\n            return _context.abrupt(\"return\", {\n              sorted: sorted,\n              labels: labels\n            });\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchTimeSeriesData(_x, _x2, _x3, _x4, _x5, _x6) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar TimeSeriesLineGraph = function TimeSeriesLineGraph(_ref2) {\n  var query = _ref2.query,\n      size = _ref2.size;\n  var type = query.type,\n      statement = query.statement,\n      start = query.start,\n      end = query.end,\n      breakdown = query.breakdown,\n      resolution = query.resolution;\n\n  var _useQuery = useQuery([type, statement, start, end, breakdown, resolution], fetchTimeSeriesData),\n      data = _useQuery.data,\n      error = _useQuery.error,\n      isLoading = _useQuery.isLoading;\n\n  if (isLoading) return \"Loading...\";\n  if (error) return \"An error has occurred: \" + error.message;\n  return !isLoading && __jsx(ResponsiveContainer, {\n    width: size === \"small\" ? 700 : \"100%\",\n    height: size === \"small\" ? 300 : \"100%\"\n  }, __jsx(LineChart, {\n    data: data.sorted,\n    margin: {\n      top: 5,\n      right: 30,\n      left: 20,\n      bottom: 5\n    }\n  }, __jsx(CartesianGrid, {\n    strokeDasharray: \"3 3\"\n  }), __jsx(XAxis, {\n    dataKey: \"time\"\n  }), __jsx(YAxis, null), __jsx(Tooltip, null), __jsx(Legend, null), data.labels.map(function (label, index) {\n    return __jsx(Line, {\n      key: index,\n      connectNulls: true,\n      type: \"monotone\",\n      dataKey: label,\n      name: label,\n      stroke: colors[index % colors.length]\n    });\n  })));\n};\n\nexport default TimeSeriesLineGraph;","map":null,"metadata":{},"sourceType":"module"}